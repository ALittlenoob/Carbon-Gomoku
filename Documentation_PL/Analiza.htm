<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <TITLE>
    Dokumentacja programu Carbon Gomoku - Analiza
  </TITLE>
</HEAD>
<BODY BGCOLOR = WHITE>
<H1>Analiza</H1>
<HR>
<H2>Podstawowe konwencje</H2>
"Kó³ko" i "Krzy¿yk" nazywam "znakami".<BR>
Mo¿liwy do wykonania ruch nazywam "kandydatem".<BR>
Na rysunkach kó³kiem oznaczam gracza, z punktu widzenia którego oceniam sytuacjê.<BR>

<H2>Analiza pojedynczego pola</H2>
<P>Przy analizie pojedynczego pola, istotne znaczenie maj¹ po 4 s¹siednie pola w ka¿dym z 8
kierunków, czyli pola które na rysunku oznaczylem gwiazdk¹:
<PRE>
*   *   *
 *  *  *
  * * *
   ***
****O****
   ***
  * * *
 *  *  *
*   *   *
</PRE>

<H3>Analiza dla jednego kierunku</H3>
<P>Wszystkie mo¿liwe uk³ady 8 s¹siednich pól w jednym kierunku podzieli³em na klasy:
<PRE>
OOOO_   9  "niekryta czwórka"
.OOO_   8  "niekryta trójka"
XOOO_   7  "kryta trójka"
..OO_   6
.XOO_   5
...O_   4
..XO_   3
...._   2
...X_   1
...X_X  0  "nic"

(kropka oznacza puste pole, podkreœlenie pole rozpatrywane).
</PRE>
Liczbê, któr¹ przypisa³em ka¿demu z tych uk³adów nazywam statusem-jeden.

<H3>Analiza dla wszystkich 4 kierunków</H3>
<P>Du¿e znaczenie maj¹ kombinacje dwóch najbardziej istotnych z czterech statusów-jeden, które
tak¿e pogrupowa³em. W poni¿szym zapisie, to co jest na lewo i na prawo od "_", wystêpuje w
ró¿nych kierunkach:
<PRE>
OOOO_        8  A
 OOO_        7  B
XOOO_OOOX    7  B
XOOO_OO      6  C
XOOO_OOX     5  D
XOOO_O       5  D
XOOO_OX      4  E
XOOO_        4  E
  OO_OO      3  F
  OO_OOX     2  G
  OO_O       2  G
  OO_OX      1  H
  OO_        1  H
inne         0
</PRE>
Tym razem liczby przypisane kombinacjom uk³adów z ró¿nych kierunków s¹ nazwane statusem-cztery pola
i w kodzie pos³ugujê siê do ich opisu typem wyliczeniowym o elementach A, B, C, ..., H. Przy czym
uporz¹dkowanie jest od A (najwiêksza wartoœæ) do H (najmniejsza). H ma wartoœæ 1, a wszystkie
pozosta³e mo¿liwe uk³ady oznaczam przez 0.


<H3>Rozwi¹zanie sk³adowania informacji o stanie pola</H3>
Najprostszym rozwi¹zaniem by³oby pamiêtanie tylko tego, co jest na danym polu. Jest to jednak rozwi¹zanie
bardzo nieefektywne. Wymagamy, aby rozpoznawanie statusów-jeden i statusów-cztery, ka¿dego pola
by³o szybkie. W tym celu, dla ka¿dego pola pamiêtam tablicê 4 x 2 (4 kierunki, 2 znaki) liczb
8-bitowych, których ka¿dy bit oznacza, czy na przypisanej mu wzglêdnej pozycji w okreœlonym kierunku
jest okreœlony znak. Wartoœci te trzeba aktualizowaæ za ka¿dym razem gdy jakiœ znak jest wstawiany
lub usuwany z planszy. Pe³na informacja o uk³adzie 8 znaków w jednym kierunku jest wiec zapisana
w dwóch 8-bitowych liczbach (w kodzie tablica <tt>pattern</tt>). Status-jeden ³atwo wiêc zapamiêtaæ
w obliczonej wstêpnie tablicy od rozmiarach 256 x 256. Status-cztery znajdujê natomiast w tablicy
10x10x10x10 elementów, której ka¿dy z 4 indeksów oznacza wartoœæ statusu-jeden ka¿dego z 4 kierunków.

<H2>Ocena sytuacji</H2>
Funkcja oceniaj¹ca bie¿¹c¹ pozycjê, czyli przypisuj¹ca jej pewn¹ wartoœæ, tym wiêksz¹, im jest lepsza
z punktu widzenia aktualnego gracza, jest podstaw¹ u¿ytego algorytmu. Mo¿na j¹ skonstruowaæ na wiele
ró¿nych sposobów. Ja przyj¹³em, ¿e osobno oceniê sytuacjê ka¿dego znaku na planszy i wyniki posumujê
(z minusem dla znaków przeciwnika). Ocenianie jednego znaku rozbi³em dalej na sumê ocen ka¿dego z czterech
kierunków. Ka¿dy z czterem kierunków oceniam na podstawie liczby mo¿liwych u³o¿eñ wygrywaj¹cej pi¹tki,
przechodz¹cej przez to pole, za pomoc¹ wykonania od 1 do 5 ruchów. Dla ka¿dej mo¿liwoœci u³o¿nia pi¹tki
w jednym ruchu dajê 19 punktów, dla 2 ruchów 15, dla 3 ruchów 11, dla 4 ruchów 7, dla 5 ruchów 3.
Wartoœæ oceny sytuacji z punktu widzenia gracza kó³kiem ró¿ni siê znakiem od wartoœci oceny tej samej
sytuacji z punktu widzenia gracza krzy¿ykiem. Przyj¹³em wartoœæ sytuacji wygranej równ¹ WIN_MAX=30000.
Jest to wygrana ju¿. Wygrana w n ruchach ma wartoœæ WIN_MAX-n;

<H2>Algorytm minimax</H2>
Algorytm minimax jest algorytmem rekurencyjnym, który przeszukuje (wykonuj¹c i cofaj¹c) mo¿liwe ruchy
okreœlon¹ liczbê (kilka) ruchów do przodu. Najdalsze pozycje oceniane s¹ funkcj¹ heurystyczn¹ i zwracany
jest w wyniku najlepszy ruch i jego wartoœæ. Na jednym poziomie rekurencji rozpatruje siê jedn¹ sytuacjê
i mo¿liwe do wykonania ruchy. Po utworzeniu listy mo¿liwych ruchów, ka¿dy z nich jest wykonywany,
algorytm dla zmienionej sytuacji wykonywany jest rekurencyjnie ze zmniejszon¹ o jeden g³êbokoœci¹
przeszukiwania (za ka¿dym razem z punktu widzenia przeciwnego gracza), a nastêpnie ruch jest cofany
i analizuje siê nastêpny. Jako najlepszy wybiera siê ruch, po którym najlepszy mo¿liwy kolejny by³
najgorszy ze wszystkich najlepszych po pozosta³ych mo¿liwych ruchach (regu³a mini-max). Wygl¹da to tak,
¿e wybieramy ruch, po którym wartoœæ najlepszego ruchu z wywo³ania rekurencyjnego wziêta z przeciwnym
znakiem jest najwiêksza i ta wartoœæ jest wartoœci¹ najlepszego ruchu z bie¿¹cego poziomu rekurencji.

<H2>Algorytm minimax z odciêciami</H2>
Algorytm minimax mo¿na bardzo ulepszyæ stosuj¹c tzw. odciêcia. Analizuj¹c drzewo ruchów, mo¿na zauwa¿yæ,
¿e pewne jego ga³êzie s¹ przegl¹dane zupe³nie niepotrzebnie. Po przeanalizowaniu czêœci mo¿liwych ruchów,
na pewnym poziomie rekurecji (1),
mamy pewien ruch, który aktualnie uznajemy za najlepszy. Oznaczmy jego wartoœæ przez <tt>-beta</tt>. Je¿eli
w kolejnym wywo³aniu rekurencji (2) bedziemy mieli ju¿ ruch o wartoœci wiêkszej od <tt>beta</tt>, to wiadomo,
¿e wynik tego wywo³ania i tak nie wp³ynie na wybór najepszego ruchu na poprzednim poziomie (1), poniewa¿
zwrócona do poprzedniego poziomu (1) wartoœæ ruchu, bêdzie i tak mniejsza od wartoœci ruchu, który jest tam (1)
uznawany za dotychczas najlepszy. Teraz maj¹c dodatkowy parametr beta (2), zauwa¿ymy, ¿e je¿eli w kolejnym (3)
wywo³aniu uzyskamy wartoœæ ruchu mniejsz¹ od -beta, czyli gdy zmienimy znak, bêdzie to wartoœæ wiêsza od
beta, to te ruchy i tak nie wp³yn¹ na wybór najlepszego dwa poziomy wy¿ej w rekurencji (1), bo najlepszy ruch
o poziom wy¿ej (2) przekroczy wartoœæ beta, czyli bêdzie gorszy od dotychczas najlepszego dwa poziomy wy¿ej (1).
W ten sposób wprowadzamy parametr <tt>alpha</tt> (równy -beta dla poprzedniego poziomu), który u¿yty jako
pocz¹tkowa wartoœæ najlepszego ruchu, powoduje uzyskanie lepszej (mniejszej) wartoœci parametru beta,
w nastêpnym wywo³aniu rekurencji.

<H2>Dalsze ulepszenia</H2>
Efektywnoœæ ciêæ alpha-beta silnie zale¿y od kolejnoœci analizowania ruchów. Najlepiej jest gdy ruchy najlepsze
s¹ analizowane jako pierwsze. Wtedy z³o¿onoœæ algorytmu jest rzêdu pierwiastka kwadratowego z³o¿onoœci dla
przypadku odwrotnego (najgorszego). Jako, ¿e nie mo¿na z góry przewidzieæ, który ruch bêdzie najlepszy (nie
mia³o by wtedy sensu przeszukiwanie), ka¿dy ruch jest wstêpnie oceniany w sposób przybli¿ony. S³u¿y do tego
funkcja, która w sposób podobny jak w funkcji oceniaj¹cej ca³¹ pozycjê, ocenia pole na podstawie
stablicowanych, wczeœniej przeliczonych wartoœci przyporz¹dkowanych ka¿demu uk³adowi dla 4 kierunków. W moim
programie jest to tablica PRIOR, której dwoma indeksami s¹ wartoœci bitowej reprezentacji uk³adu (2 liczby 8-bitowe).
Tak przygotowanych kandydatów odpowiedznio sortujemy i dopiero przetwarzamy.

<H2>Wiedza ekspercka</H2>
Dalej mo¿na poprawiaæ umiejêtnoœci algorytmu wbudowuj¹c rozwi¹zania typowych sytuacji. I tak nauczy³em mój
algorytm bez zbêdnej analizy ustawiaæ znak w sytuacjach, o których wiadomo na podstawie wartoœci status-cztery,
¿e s¹ wygrywaj¹ce i analogocznie blokowaæ przeciwnika. Zrealizowa³em to w funkcji generuj¹cej listê kandydatów.
Jest to: ustawianie pi¹tki, blokowanie czwórki przeciwnika, ustawianie nie krytej czwórki oraz blokowanie nie
krytej trójki przeciwnika.<BR> Ponadto algorytm rozpoznaje przes¹dzone pozycje w funkcji szybkiego szukania
zakoñczenia (quickWinSearch). Je¿eli istnieje ruch ustawiaj¹cy pi¹tkê, lub przeciwnik ma dwie mo¿liwoœci
ustawienia pi¹tki, lub znowu my mo¿emy tak¹ mo¿liwoœæ utworzyæ, to wiadomo co jest i nie trzeba dalej sprawdzaæ.
Niektóre sytuacje s¹ niemal na pewno przes¹dzone, ale nie do koñca - wtedy poza g³ównym przeszukiwaniem
testujemy ruchy, które s¹ potencjalnie bardzo groŸne - na pola o statusie-cztery dla bie¿¹cego gracza równym
C lub F. Je¿eli przeciwnikowi trzeba zablokowaæ czwórkê, to robimy to i rekurencyjnie szukamy szybkiego
zakoñczenia.

<H2>Generowanie kandydatów</H2>
Wiele mo¿liwych ruchów mo¿na z góry odrzuciæ. Po pierwsze rozpatrujê tylko pola, które mieszcz¹ sie w prostok¹cie,
którego lewy-górny róg jest o dwa pola na lewo od najbedziej lewego niepustego pola i o dwa pola powy¿ej najbardziej
górnego niepustego pola. Analogicznie wyznaczony jest prawy-dolny róg. Po drugie odrzucam kandydatów, którzy
wstêpnie zostali bardzo nisko ocenieni (wartoœci¹ mniejsz¹ od 2).<BR>
Pocz¹tkowo zastosowa³em inne rozwi¹zanie - listê kandydatów, aktualizowan¹ po ka¿dym ruchu i cofniêciu, ale
okaza³o siê to nie szybsze, a za to du¿o bardziej zawi³e.

<H2>Tablica transpozycji</H2>
Mo¿liwe jest uzyskanie tej samiej sytuacji w wyniku wykonywania ruchów w innej kolejnoœci. Aby nie analizowaæ
kilkakrotnie tych samych sytuacji zastosowa³em s³ownik w postaci tablicy mieszaj¹cej, w którym zapamiêtujê wynik
analizowania sytuacji. Potrzebne jest do tego generowanie sygnatury sytuacji, o czym jest mowa w kolejnym punkcie.
Do zapamiêtania wyniku uprawnieni jesteœmy jednak tylko w sytucji, gdy otrzymana wartoœæ najlepszego ruchu zawiera
sie w oknie alpha-beta, w przeciwnym razie wynik jest ró¿ny dla ró¿nych okien. Ponownie mo¿emy skorzystaæ z tego
wyniku tylko wtedy, gdy przeszukujemy ponownie na tê sam¹ g³êbokoœæ.<BR>
Dodatkowym atutem s³ownika ruchów jest mo¿liwoœæ (z której skorzysta³em) zapamiêtywania najlepszego kolejnego
ruchu, który bêdzie rozpatrywany jako pierwszy przy g³êbszym przeszukiwaniu, co polepsza efektywnoœæ ciêæ (-> Dalsze
ulepszenia). Jest to skuteczne, poniewa¿ przed rozpoczêciem przeszukiwania, dysponujemy w tym momencie, wynikami
przeszukiwania z poprzedniej kolejki.<BR>
Alternatyw¹ wobec tablicy transpozycji mo¿e byæ zapamiêtywanie struktury drzewa ruchów. Takie rozwi¹zanie mog³o by
z powodzeniem radziæ sobie z pamiêtaniem kolejnego najlepszego ruchu, ale nie rozwi¹zuje problemu ponownego
analizowania tych samych sytuacji otrzymanych w wyniku ró¿nej kolejnoœci ruchów.

<H2>Sygnatury sytuacji</H2>
Ka¿demu polu na planszy przyporz¹dkowane s¹ 2 liczby losowe, które wchodz¹ do sumy - pierwsza gdy na polu
jest kó³ko, druga, gdy krzy¿yk. Suma dla wszystkich zajêtych pól jest sygnatur¹ sytuacji. Ca³kowity rozmiar
sygnatury wynosci 64 bity + liczba bitów odpowiadaj¹ca rozmiarowi tablicy (tylko czêœc sygnatury s³u¿y do
indeksowania tablicy, reszta jest potrzebna do odró¿niania ró¿nych sytuacji). Dla tablicy 64k elementowej jest
w sumie 80 bitów. Zastosowana funkcja mieszaj¹ca nie jest matematycznie ca³kowicie poprawna, ale zak³adam,
¿e wyst¹powanie kolizji jest dla 80 bitów skrajnie ¿adkie, tak ¿e mo¿na siê tym nie przejmowaæ (w najgorszym
wypadku spowoduje to gorsz¹ grê komputera, ale nie b³¹d wykonania). Rozmiar tablicy mieszaj¹cej powinien
byæ porównywalny z liczb¹ ruchów analizowanych w jednej kolejce. Kolizjami w tablicy w ogóle siê nie
przejmujê, poniewa¿ tak jest szybciej, a utrata wa¿nej informacji zdarza siê rzadko i nie powoduje du¿ych
konsekwencji.
</BODY>
