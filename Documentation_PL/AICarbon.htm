<HTML>
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <TITLE>
    Dokumentacja programu Carbon Gomoku - algorytm AICarbon
  </TITLE>
</HEAD>
<BODY BGCOLOR = WHITE>
<H1>Algorytm AICarbon</H1>
<HR>
<H2>Pliki</H2>
AICarbon.cpp, AICarbonMove.cpp, AICarbon.h

<H2>Opis</H2>
Zawiera definicjê klasy AICarbon, która jest pochodn¹ OXPlayer.

<H2>Nowe typy danych</H2>

<TABLE BORDER>
<TR><TD><tt>OXMove</tt><TD>Wspólrzêdne ruchu i jego wartoœæ.
<TR><TD><tt>OXCand</tt><TD>To samo co OXMove, ale zamiast wartoœci jest jej oszacowanie.
<TR><TD><tt>OXCell</tt><TD>Stan pojedynczego pola na planszy.
</TABLE>

<H2>Opis OXCell</H2>
<TABLE BORDER>
<TR><TD><tt>OXPiece piece</tt><TD>Xawartoœæ pola
<TR><TD><tt>UCHAR   pattern[4][2]</tt><TD>Uk³ad dla 4 kierunków i 2 graczy, kodowany na bitach.
<TR><TD><tt>UCHAR   status1[4][2]</tt><TD>Statusy-jeden dla obu graczy i czterech kierunków.
<TR><TD><tt>UCHAR   status4[2]</tt><TD>Statusy-cztery pola dla obu graczy.
<TR><TD><tt>char    adj1, adj2</tt><TD>Czy w odleg³oœci 1 (adj1) lub 2 (adj2) znajduje siê niepuste pole?
<TR><TD><tt>void update1(int k)</tt><TD>Oblicza status-jeden kierunku k (0..3) na podstawie tablicy <tt>pattern</tt>
<TR><TD><tt>void update4()</tt><TD>Oblicza status-cztery pola na podstwie tablicy <tt>status1</tt>
<TR><TD><tt>short prior()</tt><TD>Zwraca oszacowanie wartoœci pola, które jest wykorzystywane do ustalania kolejnoœci analizowania ruchów.
</TABLE>

<H2>Nowe pola klasy AICarbon</H2>
<TABLE BORDER>
<TR><TD VALIGN = TOP><pre>OXCell  cell[BSIZE][BSIZE];<TD>Tablica pól z marginesem o szerokosci 4, który pozwala unikn¹æ sprawdzania zakresów.
<TR><TD VALIGN = TOP><pre>int     boardSize;<TD>Rozmiar planszy.
<TR><TD VALIGN = TOP><pre>int     moveCount;<TD>Liczba wykonanych ruchów od pocz¹tku gry.
<TR><TD><pre>OXPiece who, opp;<TD>Aktualny i nastêpny gracz.
<TR><TD><pre>int     nSt[2][9];<TD>nSt[i][j] - liczba pól o statusie j gracza i.
<TR><TD><pre>OXPoint upperLeftCand, lowerRightCand<TD>Lewe-górne i prawe-dolne ograniczenie dla przeszukiwania ruchów.
<TR><TD><pre>OXPoint remMove[MAX_CELLS];<TD>Zapamiêtuje kolejne ruchy.
<TR><TD><pre>OXPoint remULCand[MAX_CELLS];<TD>Zapamiêtuje <tt>upperLeftCand</tt>
<TR><TD><pre>OXPoint remLRCand[MAX_CELLS];<TD>Zapamiêtuje <tt>lowerRightCand</tt>
<TR><TD><pre>HashTable table;<TD>Tablica transpozycji.
<TR><TD><pre>int totalSearche, nSearched;<TD>Liczba przeszukanych ruchów w ogóle i w ostatniej kolejce.
</TABLE>

<H2>Nowe metody klasy AICarbon</H2>
<TABLE BORDER>
<TR><TD  VALIGN = TOP><PRE>void   _move(int x, int y);<TD>Wykonanie ruchu, wspó³rzêdne w przedziale 4..boardSize+3
<TR><TD  VALIGN = TOP><PRE>void   init();<TD>Inicjacja tablic.
<TR><TD  VALIGN = TOP><PRE>int    getRank(char cfg);<TD>Podaje liczbê punktów konfiguracji <tt>cfg</tt>, która jest wartoœci¹ w tablicy CONFIG.
<TR><TD  VALIGN = TOP><PRE>int    getPrior(UCHAR a, UCHAR b);<TD>Podaje priorytet uk³adu, kodowanego bitowo.
<TR><TD  VALIGN = TOP><PRE>UCHAR  getStatus4(UCHAR s0, UCHAR s1, UCHAR s2, UCHAR s3);<TD>Oblicza status-cztery na podstawie czterech statusów kierunków.
<TR><TD  VALIGN = TOP><PRE>int    evaluate();<TD>Ocena bie¿¹cej sytuacji.
<TR><TD  VALIGN = TOP><PRE>OXMove minimax(int h, bool root, int alpha, int beta);<TD>Szuka najlepszego ruchu o wartoœci w przedziale alpha-beta, analizuj¹c h ruchów wprzód. Parametr root okreœla, czy jest to pierwsze wywo³anie.
<TR><TD  VALIGN = TOP><PRE>int    quickWinSearch();<TD>Szybkie znajdowanie zakoñczenia. Zwrot: niezero - sytuacja przes¹dzona, liczba dodatnia - liczba ruchów do wygranej, ujemna - minus liczba ruchów do przegranej.
<TR><TD  VALIGN = TOP><PRE>void   generateCand(OXCand *cnd, int &nCnd);<TD>Tworzy listê <tt>nCnd</tt> elementow¹ kandydatów na ruch w tablicy <tt>cnd</tt>.
</TABLE>
<BR>
Makro FOR_EVERY_CAND(x, y) dzia³a jak pêtla, która wpisuje w zmienne x i y typu short kolejne propozycje ruchów.

</BODY>
